name: AI Security + Architecture Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to review (optional). Leave empty to run a smoke test only."
        required: false
        type: string

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ai-review-${{ github.event.pull_request.number || inputs.pr_number || github.run_id }}
  cancel-in-progress: true

jobs:
  ai_review:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.pull_request.draft == false }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Determine PR number (PR event -> from event; manual -> from input)
      - name: Resolve PR number
        id: pr
        run: |
          set -euo pipefail
          PR_FROM_EVENT="${{ github.event.pull_request.number }}"
          PR_FROM_INPUT="${{ inputs.pr_number }}"
          if [ -n "$PR_FROM_EVENT" ]; then
            echo "pr=$PR_FROM_EVENT" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ -n "$PR_FROM_INPUT" ]; then
            echo "pr=$PR_FROM_INPUT" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "pr=" >> "$GITHUB_OUTPUT"

      # Fetch diff ONLY if we have a PR number.
      - name: Fetch PR diff (bounded)
        if: ${{ steps.pr.outputs.pr != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
          PR: ${{ steps.pr.outputs.pr }}
        run: |
          set -euo pipefail

          gh api \
            -H "Accept: application/vnd.github.v3.diff" \
            "/repos/${GITHUB_REPOSITORY}/pulls/${PR}" > pr.diff

          python - <<'PY'
          cap_bytes = 180_000   # hard cap (~180KB)
          cap_chars = 120_000   # additional soft cap to control tokens
          p = "pr.diff"
          data = open(p, "rb").read()
          if len(data) > cap_bytes:
              data = data[:cap_bytes] + b"\n\n---\n[TRUNCATED: diff too large]\n"
          text = data.decode("utf-8", errors="replace")
          if len(text) > cap_chars:
              text = text[:cap_chars] + "\n\n---\n[TRUNCATED: diff too large (chars)]\n"
          open(p, "w", encoding="utf-8").write(text)
          print("diff_bytes", len(text.encode("utf-8")))
          PY

      # Optional: if no PR number, do a smoke test that the job can run.
      - name: No PR provided (smoke test)
        if: ${{ steps.pr.outputs.pr == '' }}
        run: |
          echo "No PR number available. This run is a smoke test only."
          echo "Tip: Run via PR event (recommended) or provide workflow_dispatch input pr_number."

      # Stop early on smoke tests (no PR).
      - name: Stop (no PR)
        if: ${{ steps.pr.outputs.pr == '' }}
        run: exit 0

      - name: Reduce noise (skip common generated/lock files)
        run: |
          python - <<'PY'
          import re, pathlib
          p = pathlib.Path("pr.diff")
          s = p.read_text(encoding="utf-8", errors="replace")

          # Drop hunks for noisy paths (best-effort). This is intentionally simple.
          noisy = [
            r'package-lock\.json', r'yarn\.lock', r'pnpm-lock\.yaml',
            r'poetry\.lock', r'Pipfile\.lock',
            r'\bdist/', r'\bbuild/', r'\bvendor/', r'\bnode_modules/',
            r'\.min\.js$', r'\.map$'
          ]

          # If a "diff --git a/... b/..." section matches noisy, remove that whole section.
          sections = re.split(r'(?=^diff --git )', s, flags=re.M)
          keep=[]
          for sec in sections:
            if not sec.strip():
              continue
            m=re.search(r'^diff --git a/(.+?) b/', sec, flags=re.M)
            path = m.group(1) if m else ""
            if any(re.search(pat, path) for pat in noisy):
              continue
            keep.append(sec)
          out = "".join(keep) if keep else s
          p.write_text(out, encoding="utf-8")
          PY

      - name: Redact obvious secrets (basic)
        run: |
          python - <<'PY'
          import re
          p = "pr.diff"
          s = open(p, "r", encoding="utf-8", errors="replace").read()

          patterns = [
            (r'sk-[A-Za-z0-9]{16,}', 'sk-[REDACTED]'),
            (r'ghp_[A-Za-z0-9]{20,}', 'ghp_[REDACTED]'),
            (r'(?i)\b(password|passwd|secret|token|api[_-]?key)\b\s*[:=]\s*["\']?([^\s"\']{8,})["\']?', r'\1: [REDACTED]'),
          ]
          for pat, rep in patterns:
              s = re.sub(pat, rep, s)

          open(p, "w", encoding="utf-8").write(s)
          PY

      - name: Build AI prompt
        run: |
          cat > prompt.txt <<'EOF'
          You are a senior security engineer and software architect doing a PR review.

          Focus:
          - Security: authn/authz, injection, secrets leakage, permissions, SSRF, deserialization, supply chain, crypto misuse, data leakage, logging/PII.
          - Architecture: module boundaries, coupling, API design, error handling, scalability, reliability, observability.

          Requirements:
          - Be specific: cite file paths / functions / diff hunks.
          - Provide concrete fixes and suggested tests.
          - If diff is truncated, state assumptions and request missing context.

          Output (Markdown):
          1) Summary (3-6 bullets)
          2) Security Findings (table: Severity | Area | Finding | Evidence | Fix)
          3) Architecture Findings (table: Severity | Area | Finding | Evidence | Fix)
          4) Suggested Tests
          5) Questions / Missing Context
          6) Quick Wins (<=5 bullets)

          Severity: Critical / High / Medium / Low / Info
          EOF

      - name: Call OpenAI (Responses API)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          AI_REVIEW_MODEL: ${{ vars.AI_REVIEW_MODEL }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, json, urllib.request, urllib.error, time

          api_key = os.environ["OPENAI_API_KEY"]
          model = os.environ.get("AI_REVIEW_MODEL") or "gpt-4.1-mini"

          prompt = open("prompt.txt", "r", encoding="utf-8").read()
          diff = open("pr.diff", "r", encoding="utf-8", errors="replace").read()

          payload = {
            "model": model,
            "input": [
              {"role": "system", "content": "You produce thorough yet concise security + architecture PR reviews."},
              {"role": "user", "content": prompt + "\n\n---\nPR DIFF:\n\n" + diff}
            ]
          }

          def call():
            req = urllib.request.Request(
              "https://api.openai.com/v1/responses",
              data=json.dumps(payload).encode("utf-8"),
              headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
              },
              method="POST"
            )
            with urllib.request.urlopen(req, timeout=180) as resp:
              return json.loads(resp.read().decode("utf-8"))

          # Simple retry for 429 / transient errors (helps early-stage stability)
          last_err = None
          for attempt in range(1, 4):
            try:
              data = call()
              break
            except urllib.error.HTTPError as e:
              last_err = e
              if e.code == 429 and attempt < 3:
                time.sleep(2 ** attempt)
                continue
              raise
            except Exception as e:
              last_err = e
              if attempt < 3:
                time.sleep(2 ** attempt)
                continue
              raise

          text = ""
          for item in data.get("output", []):
            if item.get("type") == "message":
              for c in item.get("content", []):
                if c.get("type") == "output_text":
                  text += c.get("text", "")

          if not text.strip():
            text = "AI returned no text output."

          open("review.md", "w", encoding="utf-8").write(text.strip() + "\n")
          print("review.md written")
          PY

      - name: Post PR comment + Review
        env:
          GH_TOKEN: ${{ github.token }}
          PR: ${{ steps.pr.outputs.pr }}
        run: |
          set -euo pipefail

          python - <<'PY'
          txt = open("review.md", "r", encoding="utf-8").read()
          cap = 60000
          if len(txt) > cap:
              txt = txt[:cap] + "\n\n---\n[TRUNCATED]\n"
          open("review_trimmed.md", "w", encoding="utf-8").write(txt)
          PY

          gh pr comment "$PR" --body "$(printf "## ðŸ¤– AI Security + Architecture Review (Comment)\n\n"; cat review_trimmed.md)"
          gh pr review  "$PR" --comment --body "$(printf "## ðŸ¤– AI Security + Architecture Review (Review)\n\n"; cat review_trimmed.md)"
